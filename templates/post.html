<!DOCTYPE html>
<html lang="$lang$">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>$title$</title>
    <link rel="stylesheet" href="../../assets/style.css">
    <link rel="icon" href="../../assets/favicon.ico">
</head>
<body>
    <div class="container">
        <header class="site-header">
            <div class="logo"><a id="site-title" href="$base-path$/">microdancing</a></div>
            <nav>
                <a href="$base-path$/$lang$/">$nav-home$</a>
                <a href="$base-path$/es/" lang="es">ES</a>
                <a href="$base-path$/en/" lang="en">EN</a>
            </nav>
        </header>
        <main>
            <article>
                <header>
                    <h1>$title$</h1>
                    $if(date)$<time>$date$</time>$endif$
                </header>
                $body$
            </article>
        </main>
        <footer>
            <p>$footer$</p>
        </footer>
    </div>
    <script>
        const titles = ["Haciendo lo que más me gusta", "No esperes nada de mí, no esperes nada de mí"];
        document.getElementById("site-title").textContent = titles[Math.floor(Math.random() * titles.length)];

        // Progress indicator for long reads
        (function() {
            const markers = document.querySelectorAll('.progress-marker');
            if (markers.length === 0) return;

            const indicator = document.createElement('div');
            indicator.className = 'progress-indicator';
            document.body.appendChild(indicator);

            let ticking = false;
            window.addEventListener('scroll', function() {
                if (!ticking) {
                    window.requestAnimationFrame(function() {
                        const scrollY = window.scrollY;
                        const windowHeight = window.innerHeight;
                        let current = 0;

                        markers.forEach((marker, i) => {
                            if (marker.getBoundingClientRect().top < windowHeight * 0.5) {
                                current = i + 1;
                            }
                        });

                        if (scrollY > 200) {
                            indicator.textContent = current + '/' + markers.length;
                            indicator.classList.add('visible');
                        } else {
                            indicator.classList.remove('visible');
                        }
                        ticking = false;
                    });
                    ticking = true;
                }
            });
        })();

        // Footnote popovers
        (function() {
            const footnoteRefs = document.querySelectorAll('.footnote-ref');
            if (footnoteRefs.length === 0) return;

            let activePopover = null;
            let activeRef = null;

            function closePopover() {
                if (activePopover) {
                    activePopover.remove();
                    activePopover = null;
                    activeRef = null;
                }
            }

            function createPopover(content, anchorEl) {
                closePopover();

                const popover = document.createElement('div');
                popover.className = 'footnote-popover';
                popover.innerHTML = '<div class="footnote-popover-content">' + content + '</div>';
                document.body.appendChild(popover);

                activePopover = popover;
                activeRef = anchorEl;

                // Position after a frame so dimensions are calculated
                requestAnimationFrame(function() {
                    const rect = anchorEl.getBoundingClientRect();
                    const popoverRect = popover.getBoundingClientRect();

                    let top = rect.bottom + window.scrollY + 8;
                    let left = rect.left + window.scrollX + (rect.width / 2) - (popoverRect.width / 2);

                    // Keep within viewport
                    const padding = 16;
                    if (left < padding) left = padding;
                    if (left + popoverRect.width > window.innerWidth - padding) {
                        left = window.innerWidth - popoverRect.width - padding;
                    }

                    popover.style.top = top + 'px';
                    popover.style.left = left + 'px';
                    popover.classList.add('visible');
                });
            }

            footnoteRefs.forEach(function(ref) {
                ref.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    // Toggle if clicking the same footnote
                    if (activeRef === this) {
                        closePopover();
                        return;
                    }

                    const targetId = this.getAttribute('href').substring(1);
                    const footnote = document.getElementById(targetId);

                    if (!footnote) return;

                    // Clone and clean the footnote content
                    const clone = footnote.cloneNode(true);
                    clone.querySelectorAll('.footnote-back').forEach(function(el) { el.remove(); });

                    createPopover(clone.innerHTML, this);
                });
            });

            // Close on click outside
            document.addEventListener('click', function(e) {
                if (activePopover && !activePopover.contains(e.target) && !e.target.closest('.footnote-ref')) {
                    closePopover();
                }
            });

            // Close on Escape
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') closePopover();
            });
        })();
    </script>
</body>
</html>
